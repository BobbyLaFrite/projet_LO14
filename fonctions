#!/bin/bash

#-----------------------------FUNCTIONS------------------------------------------------------
#-----------------------------EXTRACT--------------------------------------------------------
function command-extract(){
	if [ -e $1 ]&&[ -f $1 ];then
		echo "Extracting..."

		#recover header lines
		endLine=$(echo $(head $1 -n 1) | cut -d':' -f2) #f2 cuts after ':'
		startLine=$(echo $(head $1 -n 1) | cut -d':' -f1)

		#spliting header and body
		header=$(echo "$(head $1 -n $(($endLine-1)))" | tail -n +$startLine)
		body="$(tail $1 -n +$endLine)"

		#extracting and creating files
		#replacing \ with / to use basic commands
		header=$(echo "$header" | sed -e 's/\\/\//g')
		#saving base directory
		currentDirectory=$(pwd)

		echo "$header"|while read l
		do
			firstWord=$(echo $l | cut -d' ' -f1)

			#if first word is "directory" we've got to move to the desired location (2nd word)
			if [ $firstWord = "directory" ];then
				#moving to directory, and if it doesn't exist, create one
				directory=$(echo $l | cut -d' ' -f2)
				cd $directory || {
				echo "Creating base directory...";
				mkdir -p $directory;
				cd $directory
				echo $(pwd)
				}
			
			elif [ $firstWord = "@" ];then
				#moving back
				cd $currentDirectory
			else
				#creating subsequent directories and files
				secondWord=$(echo $l | cut -d' ' -f2)
				
				#getting first letters and rights
				SWfirstLetter=${secondWord:0:1}
				SWrights=${secondWord:1}

				
				#getting rights
				octalRights=""
				#separating users rights
				for (( i = 1; i < 4; i++ )); do
					#octal right convert for instance rw- to one number
					octalRight=0
					right=$(echo $SWrights | cut -c$(($i*3-2))-$(($i*3)) )

					#converting r,w and x to number
					if [ ${right:0:1} = "r" ];then
						let octalRight+=4
					fi
					if [ ${right:1:1} = "w" ];then
						let octalRight+=2
					fi
					if [ ${right:2:1} = "x" ];then
						let octalRight+=1
					fi
					octalRights+="$octalRight"
				done
				
				
				#if the object is a directory
				if [ $SWfirstLetter = "d" ];then

					#creating the directory
					mkdir -m $octalRights $firstWord
				
				#if it's a file
				elif [ $SWfirstLetter = "-" ];then

					#creating the file
					touch $firstWord
					chmod $octalRights $firstWord

					#filing the files
					#if the file has a size different than 0
					if [ $(echo $l | cut -d' ' -f3) != "0" ]; then
						startLine=$(echo $l | cut -d' ' -f4)
						length=$(echo $l | cut -d' ' -f5)
						content=$(echo "$body" | sed -n -e $startLine,$(($startLine+$length-1))p )
						echo "$content" > $firstWord
					fi
				else
					echo "File type couldn't be recognized"
				fi

			fi
		done

		echo "Done !"

	else
		echo "File couldn't be found"
	fi	
}
#-----------------------------CREATE---------------------------------------------------------
function command-create(){
	

	currentDirectory=$(pwd)
	nextLocation="/Exemple/Test" #a initialiser à "" une fois le server créé

	#create archive, normaly on client side
	archName=$1
	#creating archive
	touch $archName
	#reset content
	> $archName
	#creating tmp file
	touch "tmp-$$"
	>"tmp-$$"

	browsing-files $currentDirectory $nextLocation 1
	#adding the temp file to the arch
	cd $currentDirectory

	sizeOfHeader=$(wc -l $archName | cut -d' ' -f1)
	let sizeOfHeader+=3

	#write fisrt line on top of the archfile
	echo -e "3:$sizeOfHeader\n" | cat - $archName > temp && mv temp $archName


	cat "tmp-$$">>$archName
	rm  "tmp-$$"
}

function browsing-files(){
	#recursive function
	#get arch location
	archLocation=$1
	#get the next location
	local nextLocation=$2
	#get the starting line of the body
	startingLineOfBody=$3

	cd $archLocation$nextLocation
	#create first line of the directory infos
	echo "directory ${nextLocation:1}" | sed -e 's/\//\\/g'>>$archLocation"/"$archName
	currentFiles=$(ls -l | tail -n +2)

    #we have an issue here, startingLineOfBody is reseting his value after the while loop
	#workaround
	shopt -s lastpipe
	#first loop to get files names
	echo "$currentFiles" | while read l
	do 
		if [ -n "$l" ];then

			fileName=$(echo $l | cut -d' ' -f9)
			rights=$(echo $l | cut -d' ' -f1)
			size=$(echo $l | cut -d' ' -f5)

			if [ $(echo $l | cut -c 1 ) = "d" ];then
				echo $fileName $rights $size >> $archLocation"/"$archName
	 		else
	 			fileContent=$(cat $archLocation$nextLocation"/"$fileName)
	 			numberOfLines=$(echo $(echo "$fileContent" | wc -l))
	 			
	 			if [ ! $size -eq 0 ];then
	 				echo "$fileContent" >> $archLocation"/tmp-$$"
	 				echo "$fileName $rights $size  $startingLineOfBody $numberOfLines">> $archLocation"/"$archName
	 			else
	 				echo "$fileName $rights $size  $startingLineOfBody 0">> $archLocation"/"$archName
	 			fi
	 			startingLineOfBody=$(($startingLineOfBody+$numberOfLines))
			fi
		fi
	done
	echo "@" >> $archLocation"/"$archName
	#second loop to move to another directory
	#reading through the lines of ls -l
	echo "$currentFiles" | while read l
	do
		if [ -n "$l" ];then
			#if its a document, we go to the next one and start again
	 		directoryName=$(echo $l | cut -d' ' -f9)
	 		if [ $(echo $l | cut -c 1 ) = "d" ];then
	 			browsing-files $archLocation $nextLocation"/"$directoryName $startingLineOfBody
	 		fi
		fi
	done
}


#-----------------------------ARGS-----------------------------------------------------------
#stat -c '%n %A' *
if [ $# -ge 1 ];then
	func="command-$1"

	if [ "$(type -t $func)" = "function" ];then # verifying if func is a declared-function in this file
		$func $2
	else
		echo "Couldn't recognize the command"
	fi
fi
